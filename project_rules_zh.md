
# 理念

## 核心理念

- **渐进式推进优于一蹴而就** - 进行能编译并通过测试的小改动
- **从现有代码中学习** - 实施前先研究和规划
- **务实而非教条** - 适应项目实际情况
- **明确意图优于巧妙代码** - 力求简洁直白

## 简洁意味着

- 每个函数/类单一职责
- 避免过早抽象
- 不要耍小聪明，选择简单明了的解决方案
- 如果你需要解释它，那就太复杂了

# 流程

## 1. 规划与筹备

如果工作极其清晰和简单可以直接实施无需执行繁琐规划，但如果工作较为复杂需要将其分解为 3 - 5 个阶段并记录在 `PLAN.md` 中：

```
## 阶段 N：[名称]
**目标**: [具体可交付成果]
**成功标准**: [可测试结果]
**测试**: [具体测试用例]
**状态**: [未开始 | 进行中 | 已完成]
```
- 在进展过程中更新状态
- 所有阶段完成后删除 `PLAN.md` 文件

## 2. 实施流程

1. **理解** - 研究代码库中的现有模式
2. **测试** - 先编写测试（红色）
3. **实现** - 通过测试的最少代码量（绿色）
4. **重构** - 在测试通过的情况下进行整理
5. **提交** - 附上与计划相关的明确信息

## 3. 遇到困难时（尝试 3 次之后）

1. **记录失败的内容**：
   - 你尝试了什么
   - 特定错误消息
   - 你认为它失败的原因
2. **研究替代方案**:
   - 找到 2 - 3 个类似的实现方案
   - 记录所采用的不同方法
3. **问题基础**：
   - 这是合适的抽象层次吗？
   - 这可以分解为更小的问题吗？
   - 是否完全存在更简单的方法？
4. **尝试不同角度**：
   - 不同的库/框架特性？
   - 不同的架构模式？
   - 是否应该去除而非增加抽象概念？

# 技术标准

## 架构原则

- **显式优于隐式** - 清晰的数据流和依赖关系
- **尽可能采用测试驱动** - 永远不要禁用测试，而是修复它们

## 代码质量

- **每次提交必须**：
  - 编译成功
  - 遵循项目格式/代码检查规范
- **提交前**：
  - 运行格式化程序/代码检查工具
  - 自我审查变更
  - 确保提交信息解释“原因”

## 错误处理

- 快速失败并给出描述性信息
- 包含用于调试的上下文
- 在适当层面处理错误
- 永远不要默默地忽略异常

# 决策框架

当存在多种可行的方法时，可基于以下方面进行选择：

- **可测试性** - 我能轻松测试这个吗？
- **可读性** - 6 个月后有人能理解这段内容吗？
- **一致性** - 这与项目模式匹配吗？
- **简洁性** - 这是可行的最简解决方案吗？
- **可逆性** - 日后变更的难度有多大？

# 项目整合

## 学习代码库

- 找出 3 个相似的特征/组件
- 识别常见的模式和惯例
- 尽可能使用相同的库/工具
- 遵循现有的测试模式

## 工具

- 使用项目现有的构建系统
- 使用项目的测试框架
- 使用项目的格式化程序/代码检查工具设置
- 没有充分理由，请勿引入新工具

# 编码规范

## 开发规范

### 代码组织

- 业务模块遵循一致的结构：
  ```
  modules/{module-name}/
  ├── components/    # 模块特定组件
  ├── services/      # 模块服务抽象
  ├── hooks/         # 自定义 React hooks
  ├── utils/         # 工具函数
  ├── constants.ts   # 模块常量
  └── types.ts       # TypeScript 类型定义
  ```

### 文件规范

- 所有文件必须统一使用 **2 个空格** 作为缩进
- 文件命名使用 `kebab-case` 格式
- React 组件文件名必须以 `kebab-case` 格式与组件名相匹配

### 命名规范

- 变量/函数使用 camelCase 格式
- 类/接口/枚举/泛型参数使用 PascalCase 格式
- React 组件使用 PascalCase 格式
- 常量使用 UPPER_SNAKE_CASE 格式
- CSS 类名选择器使用 kebab-case 格式
- 布尔变量使用 `is/has/should` 前缀
- 事件处理程序使用 `handle` 前缀 + [元素名] + 事件动词
- React 组件事件属性使用 `on` 前缀 + [元素名] + 事件动词

### TypeScript 约定

- 严格的 TypeScript，不允许使用 `any` 类型
- 组件 props 接口命名为 `I{ComponentName}Props`
- 仅用于类型时使用 `import type` 进行类型导入
- 显式类型断言必须使用 `as` 语法

### React 模式

- 仅使用函数组件，每个文件只包含一个 React 组件
- 组件属性必须有接口或类型声明，命名为 `[ComponentName]Props`
- 组件样式文件必须使用与组件文件相同的名称，后缀为 `.module.scss`
- `useCallback`/`useEffect`/`useMemo` 必须明确声明所有外部依赖项
- 大型组件或弱依赖组件使用 `SafeContainer` 搭配 `React.lazy` 使用


# 重要提醒

## 不要

- 使用 `--no-verify` 绕过提交钩子
- 提交无法编译的代码
- 做和任务无关的动作

## 必须

- 使用中文表达
- 逐步提交可运行的代码
- 在推进过程中更新计划文档
- 从现有代码实现中学习模式
- 3 次尝试失败后停止并重新评估
